ðŸ”º datetime object -> df['Date']= pd.to_datetime(df['Timestamp'], unit='s')

ðŸ”º df = df[~df['Date'].dt.year.isin([2012, 2013, 2014])] # or df = df[(df['year'] >= 2015) & (df['year'] <= 2025)]

ðŸ”º cols to lower case -> df.columns = df.columns.str.lower() 

ðŸ”º resampling -> df.resample('M').mean() # or Y, W 
find out the highest average month -> df.resample('M').mean()['close'].idxmax() 

ðŸ”º rolling window calculations -> df['7_day_rolling'] = df['close'].rolling(window = 1000).mean() 

df['close'].pct_change() * 100

ðŸ”º lagged values -> df['closed_lag1']= df['close'].shift(1)

ðŸ”º SEASONAL DECOMPOSITION
- trends: general direction of the time series
- seasonality: seasonal cycles -> 2 types: 
    - additive: have constant seasonal fluctuations or seasonal cycles are constant in value
    - multiplicative: seasonal cycles are proportional to the trend (in %age)
- error term: what is not explained by trends and seasonality

ðŸ”º STATSMODEL -> TO SHOW SEASONALITY CURVE
from statsmodels.graphics.tsaplots import month_plot, quarter_plot
month_plot(df['close'].resample('M').mean(), ylabel='closing') # or 'Q'

from statsmodels.tsa.seasonal import seasonal_decompose
decomp2 = seasonal_decompose(df['close'], model='add', period = 24) # or 'mul'
fig = decomp2.plot()
fig.set_size_inches(10,8)
plt.show()

ðŸ”º AUTOCORRELATION
- tells if there is info in past that could help in predict future
- correlates time series features with lagged values

ðŸ”º TREND
from statsmodels.tsa.deterministic import DeterministicProcess
dp = DeterministicProcess(
    index=tunnel.index,  # dates from the training data
    constant=True,       # dummy feature for the bias (y_intercept)
    order=1,             # the time dummy (trend)
    drop=True,           # drop terms if necessary to avoid collinearity
)
# `in_sample` creates features for the dates given in the `index` argument
X = dp.in_sample()

ðŸ”º FORECAST 
To make a forecast, we apply our model to "out of sample" features. 
"Out of sample" refers to times outside of the observation period of the training data. Here's how we could make a 30-day forecast:

X = dp.out_of_sample(steps=30)
y_fore = pd.Series(model.predict(X), index=X.index)
y_fore.head()

ðŸ”º MOVING AVERAGE PLOT
make a moving average plot to see what kind of trend a series has. 
To create a moving average, first use the rolling method to begin a windowed computation.
(daily observation: 365, monthly observation: 12, weekly observation: 7, quarterly observation: 4)
Follow this by the mean method to compute the average over the window. 

moving_average = tunnel.rolling(
    window=365,       # 365-day window -> for daily observations
    center=True,      # puts the average at the center of the window
    min_periods=183,  # choose about half the window size
).mean()              # compute the mean (could also do median, std, min, max, ...)

ax = tunnel.plot(style=".", color="0.5")
moving_average.plot(
    ax=ax, linewidth=3, title="Tunnel Traffic - 365-Day Moving Average", legend=False,
)



